package com.vogonjeltz.physics.core

import com.vogonjeltz.physics.math.shapes.Circle
import com.vogonjeltz.physics.math.{Deg, Rotation, Vect}
import com.vogonjeltz.physics.render.{Colour, Frame, Render}
import org.lwjgl.opengl.GL11._
import Vect.VectHelper
import com.vogonjeltz.physics.utils.Log
/**
  * Particle
  *
  * Created by fredd
  */
class Particle(private var _rotation: Rotation, private var _position: Vect, val particleType: ParticleType, var _velocity: Vect = Vect.ZERO)(implicit val universe: Universe) {

  val GRAVITATIONAL_CONSTANT: Double = 6.674 * Math.pow(10, -11)
  val MAX_PATH_LENGTH = 10000
  val REST_COEFF = 1

  val mass: Double = particleType.mass
  val radius: Double = particleType.radius

  val DELTA_TIME: Double = universe.resolution

  def velocity: Vect = _velocity
  def momentum: Vect = velocity * mass

  def rotation: Rotation = _rotation
  def position: Vect = _position

  private var _tick = new Tick()
  private var _lastTick = _tick
  def tick: Tick = _tick
  def lastTick: Tick = _lastTick

  private var doPath = 0

  private var _path: List[PathPoint] = List()
  def path: List[PathPoint] = _path

  /**
    * Calculate the forces generated by the collision of this particle and another
    * @param that The particle to collide with
    * @return List of the forces generated
    */
  def collide (that: Particle): List[Force] = {

    val normal = (that.position - this.position).normalize
    val tangent = normal.tangent

    val u1 = this.velocity
    val u2 = that.velocity

    val m1 = this.mass
    val m2 = that.mass

    val u1n: Double = u1 dot normal
    val u1t: Double = u1 dot tangent
    val u2n: Double = u2 dot normal

    val v1t = u1t

    val v1n = ( ((m1-m2) * u1n) + (2 * m2 * u2n) ) / (m1 + m2)

    val vect_v1n = normal * v1n
    val vect_v1t = tangent * v1t

    val v1 = vect_v1n + vect_v1t

    val impulse1 = ((v1 * m1) - (u1 * m1)).length / DELTA_TIME

    if (impulse1 < 0.0000000001) {
      List()
    } else {

      val forces = List(
        Force(this, impulse1, (this.position - that.position).theta, alwaysDraw = true),
        Force(that, impulse1, (that.position - this.position).theta, alwaysDraw = true)
      )

      forces
    }
  }

  /**
    * Calculate the forces generated by this particle interacting with another (gravity + collision)
    * @param that The particle to interact with
    * @return (List of forces generated, did collide)
    */
  def interact(that: Particle): (List[Force], Boolean) = {
    val distance = that.position.distance(position)
    val gravForce = (GRAVITATIONAL_CONSTANT * mass * that.mass) / Math.pow(distance, 2)

    val collisionForces:List[Force] = if (this.circle.intersect(that.circle)) collide(that) else List()

    (List(
      Force(that, gravForce, (this.position - that.position).theta),
      Force(this, gravForce, (that.position - this.position).theta)
    ) ++ collisionForces, collisionForces.nonEmpty)
  }

  /**
    * Add a force to the current tick
    * @param f Force to add
    */
  def accept(f: Force): Unit = tick.addForce(f)

  /**
    * Draw the particle to the screen
    */
  def render(): Unit = {
    Render.withContext(Frame()) {
      glBegin(GL_POINTS)
      for (point <- _path) {
        val (r,g,b) = point.colour
        glColor3d(r,g,b)
        glVertex2d(point.position.x, point.position.y)
      }
      glEnd()
    }
    circle.render()
    if (particleType.fixed) return
    for (force <- lastTick.forces) force.render()
  }

  /**
    * Upadate the particle based on the forces generated since last call
    */
  def runTick(): Unit = {
    //println(mass)
    if (particleType.fixed) return

    doPath += 1
    if ((doPath % 6 == 0 && _path.nonEmpty && _path.head.position.distance(position) > radius/2) || _path.isEmpty)  {
      doPath = 0
      _path ::= PathPoint(position, velocity.length)
      if (_path.length > MAX_PATH_LENGTH && MAX_PATH_LENGTH != -1) _path = _path.init
    }

    val netForce = tick.forces.map(_.toVect).foldLeft(Vect.ZERO)(_ + _)


    val acceleration = netForce/mass

    _velocity = velocity + (acceleration * DELTA_TIME)
    _position = position + (velocity * DELTA_TIME)

    _lastTick = tick
    _tick = new Tick()

  }

  /**
    * Get the representation of this particle as a Circle
    * @return
    */
  def circle: Circle = new Circle(position, radius, particleType.colour, filled = false/*!particleType.fixed*/)

}

case class ParticleType(mass: Double, radius: Double, colour:Colour = Colour.WHITE, fixed: Boolean = false) {

  def apply(position: Vect, velocity: Vect = Vect.ZERO)(implicit universe: Universe): Particle = new Particle(Rotation.zero, position, this, velocity)
  
}

case class PathPoint(position: Vect, speed: Double) {

  private def cap(x: Double) = if (x > 1) 1d else x

  val colour: (Double, Double, Double) = {
    val g = 0d
    val r = cap(10d * Math.abs(speed))
    val b = cap(10d / Math.abs(speed))
    (r, g, b)
  }
}